				O que é ORM?
● Object Relational Mapper (ORM);
● Abstrai a complexidade das queries, para trabalharmos com métodos;
● Nos concentramos na regra de negócios e não nos comandos SQL;
● Uma ORM muito utilizada para Node.js é a Sequelize;
● Em alguns casos uma ORM pode trazer prejuízos de performance;
● A query pura executa mais rapidamente do que a ORM;
● E temos código “gerado”, ou seja, não vemos por baixo dos panos;



			O que é Sequelize?
● Uma ORM para Node.js;
● Ela é baseada em promises (then, catch);
● Tem integração para vários bancos relacionais, como o MySQL;
● Precisamos sempre criar um Model, que é o reflexo da nossa tabela em 
uma classe;
● Precisamos instalar o pacote, já que é um módulo externo;



			Instalando o Sequelize
● Para instalar o Sequelize utilizamos o pacote sequelize;
● E para conectar precisamos passar os mesmos dados que no outro 
pacote: banco, usuário e senha;
● Instanciando a classe Sequelize;
● É possível checar a conexão com o método authenticate;
● Vamos ver na prática


npm install sequelize
""   ""		mysql2

no nosso db/conn

const { Sequelize } = require('sequelize')		//Importando sequelize

const sequelize = new Sequelize('nodesequelize2', 'root', '', {
    host: 'localhost',
    dialect: 'mysql'				// Banco
})


Dpeois teremos o try e catch para conectar OU gerar algum erro // Promises

try {

    sequelize.authenticate()
    console.log('Conectamos com sucesso')



}   catch(err) {
    console.log('Não foi possível conectar: ', error)
}


e o exportamos
module.exports = sequelize

importando
const conn = require('./db/conn')








				Criando um Model
● Para criar um Model temos que instanciar uma classe que representará 
uma tabela;
● Um Model User cria uma nova tabela chamada users;
● Colocamos os campos e os tipos dele como propriedades do Model;
● Futuramente ele será utilizado para as operações entre aplicação e 
banco;
● O método sync faz a criação das tabelas baseada nos models


models/User.js

const {DataTypes} = require('sequelize') //Propriedade do sequelize

const db = require('../db/conn')

const User = db.define('User', {	define define o modulo
    name: {
        type: DataTypes.STRING,
        allowNull: false
    },
    occupation: {
        type: DataTypes.STRING,
        required: true
    }
})


e o exportamos
module.exports = User




// Conexoes
conn.sync(). then(() => {
    app.listen(3000)
}).catch((err) => console.log(err))









			Inserindo dados
● Para inserir um dado vamos precisar do Model que criamos, ou seja, 
importar ele no arquivo de execução do comando;
● O método a ser utilizado é o create;
● Ele leva como parâmetro todos os campos, e insere o registro na tabela;
● Vamos ver na prática

depois e fazer noo views de inserção

rota para mostrar a view
app.get('/users/create', (req, res) => {
    res.render('adduser')
})

e rota de post para enviar ao banco

app.post('/users/create', async (req, res) => {
    const name = req.body.name
    const occupation = req.body.occupation
    let newsletter = req.body.newsletter

    if(newsletter === 'on') {
        newsletter = true
    }

    await User.create({name, occupation, newsletter})
    res.redirect('/')
})





			Lendo dados
● Para ler os dados de uma tabela vamos utilizar o método fetchAll;
● Que também requer o model, no nosso caso o User;
● Os dados vem em um objeto especial, para transformar em um array de 
objetos temos que inserir um parâmetro;
● Que é o raw como true;
● Vamos ver na prática

na nossa rota de home

app.get('/', async (req, res) => {
    const users = await User.findAll({raw: true})

    console.log(users)

    res.render("home", {users: users})
})	adicionamos nosso model na home para utilizarmos na nossa view home





			Utilizando o WHERE
● Para filtrar dados com o Sequelize utilizando o WHERE, precisamos 
inserir um novo parâmetro;
● Que será o where, um objeto onde colocamos a propriedades e valores 
que queremos filtrar;
● E para retornar apenas um resultado podemos utilizar o método findOne


 <div class="actions">
            <a href="/users/{{this.id}}">Ver detalhes</a>
        </div>

depois de fazer nossa view de um usuario especifico fazemos nossa rota


app.get('/users/:id', async (req, res) => {
    const id = req.params.id

    const user = await User.findOne({raw:true, where: {id: id}})

    res.render('userview', { user }) 		// Nossa view e o user
})





			Removendo itens
● Para remover itens utilizando o método destroy;
● A função vai ficar bem parecida com a de resgatar um usuário;
● Só que será um POST, e que efetua a remoção, depois redirecionamos;
● Precisamos também criar um formulário no front-end;
● Vamos ver na prática

na nossaa view de home colocamos o button de del

 <form action="/users/delete/{{this.id}}" method="post">
                <input type="submit" value="excluir" class="delete-btn">
            </form>


na nossa rota de enviar: post
app.post('/users/delete/:id', async (req, res) => {
    const id = req.params.id

    await User.destroy({where: {id: id}})

    res.redirect('/')
})





			Editando itens
● O primeiro passo da edição é resgatar os dados do item;
● Com isso podemos preencher o formulário, para depois fazer o 
UPDATE;
● Vamos utilizar o método findOne, igual na rota de visualização;
● E fazer o preenchimento do form na nossa nova view;
● Vamos a prática

começando pelo front

HOME
 <a href="/users/edit/{{this.id}}" class="details-btn">Editar</a>
MANDANDO P NOSSA ROTA DO MAIN 

view/useredit.handlebars

<h1>Editando: {{user.name}}</h1>
<form action="/users/update"  method="post" class="form">  //Mandando p nossa rota


rota do back
app.get('/users/edit/:id', async (req, res) => {
    const id = req.params.id

    const user = await User.findOne({raw: true, where: {id: id}})

    res.render('useredit', {user})
})



agora precisamos do POST para efetivar a troca de dados

app.post('/users/update', async (req, res) => {
    const id = req.body.id
    const name = req.body.name				// Pegamos os dados que vem da req
    const occupation = req.body.occupation
    let newsletter = req.body.newsletter

    if(newsletter === 'on') {
        newsletter = true
    } else {
        newsletter = false
    }

    const userData = {
        id,					colocamos os dados em UM obj
        name,
        occupation,
        newsletter
    }

    await User.update(userData, { where: {id: id}}) //Mandamos o obj para o DB
})









			Refazer as tabelas
● Podemos forçar a reconstrução das tabelas;
● No método sync, onde são sincronizados os models e as tabelas;
● Vamos colocar um atributo: force como true;
● Exemplo: sync({ force: true })
● Note que os dados são perdidos neste processo;
● Vamos ver na prática





			Relacionamentos
● Em bancos relacionais podemos criar relacionamentos entre as tabelas;
● Para concretizar isso no Sequelize vamos precisar de dois Models, ou 
seja, precisamos criar mais um no nosso projeto;
● Depois precisamos inserir um método de relacionamento em algum 
dos models que vai criar a relação;
● Após o sync uma coluna que faz a relação entre as tabelas será criada;
● Que representa a FOREIGN KEY
